#include "pico/stdlib.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include <iostream>
#include <string>

//gpio pins
const uint ROT_A_PIN = 10;   //rotary A
const uint ROT_B_PIN = 11;   //rotary B
const uint ROT_SW_PIN = 12;  //switch
const uint LED_PIN = 22;     // LED

// Event types from ISR
typedef enum {
    EVENT_BUTTON,
    EVENT_ENCODER_CW,
    EVENT_ENCODER_CCW
} event_type_t;

typedef struct {
    event_type_t type;
    uint32_t timestamp;
} event_t;

// LED control
typedef enum {
    LED_CMD_TOGGLE,
    LED_CMD_SET_FREQ
} led_cmd_type_t;

typedef struct {
    led_cmd_type_t type;
    int32_t value; //frequency adjustment +/-
} led_cmd_t;

QueueHandle_t xEventQueue;
QueueHandle_t xLedCmdQueue;

uint32_t lastButtonPressTime = 0;
const uint32_t DEBOUNCE_TIME_MS = 250;
const uint32_t ENCODER_DEBOUNCE_MS = 10;

extern "C" {
    uint32_t read_runtime_ctr(void) {
        return (uint32_t)time_us_64();
    }
}

// GPIO interrupt callback for rotary encoder
void gpio_callback(uint gpio, uint32_t events) {
    static uint32_t lastEncoderTime = 0;

    event_t event;
    event.timestamp = to_ms_since_boot(get_absolute_time());

    if (gpio == ROT_SW_PIN) {
        // Button press event - check for falling edge
        if ((events & GPIO_IRQ_EDGE_FALL) &&
            (event.timestamp - lastButtonPressTime > DEBOUNCE_TIME_MS)) {
            event.type = EVENT_BUTTON;
            xQueueSendToBackFromISR(xEventQueue, &event, NULL);
            lastButtonPressTime = event.timestamp;
        }
    } else if (gpio == ROT_A_PIN) {
        // Encoder debouncing
        if (event.timestamp - lastEncoderTime < ENCODER_DEBOUNCE_MS) {
            return;
        }
        lastEncoderTime = event.timestamp;

        int a_state = gpio_get(ROT_A_PIN);
        int b_state = gpio_get(ROT_B_PIN);

        static int last_a_state = 0;

        if (a_state != last_a_state) {
            if (a_state == 1) {  // Rising edge
                if (b_state == 0) {
                    event.type = EVENT_ENCODER_CW;
                } else {
                    event.type = EVENT_ENCODER_CCW;
                }
                xQueueSendToBackFromISR(xEventQueue, &event, NULL);
            }
            last_a_state = a_state;
        }
    }
    //portEND_SWITCHING_ISR() //when the task has to be switched imideatly
}

// Task to process events and send LED commands
void eventProcessorTask(void* params) {
    event_t event;
    led_cmd_t cmd;

    while (true) {
        if (xQueueReceive(xEventQueue, &event, portMAX_DELAY) == pdTRUE) {
            switch (event.type) {
                case EVENT_BUTTON:
                    cmd.type = LED_CMD_TOGGLE;
                    xQueueSendToBack(xLedCmdQueue, &cmd, portMAX_DELAY);
                    break;

                case EVENT_ENCODER_CW:
                    cmd.type = LED_CMD_SET_FREQ;
                    cmd.value = +2;
                    xQueueSendToBack(xLedCmdQueue, &cmd, portMAX_DELAY);
                    break;

                case EVENT_ENCODER_CCW:
                    cmd.type = LED_CMD_SET_FREQ;
                    cmd.value = -2;
                    xQueueSendToBack(xLedCmdQueue, &cmd, portMAX_DELAY);
                    break;
            }
        }
    }
}

// LED blinker task (owns state)
void ledBlinkerTask(void* params) {
    TickType_t xLastWakeTime = xTaskGetTickCount();
    bool ledState = false;
    bool ledOn = false;
    uint32_t blinkFrequency = 2;  // Hz

    led_cmd_t cmd;

    while (true) {
        // Handle incoming commands
        if (xQueueReceive(xLedCmdQueue, &cmd, 0) == pdTRUE) {
            switch (cmd.type) {
                case LED_CMD_TOGGLE:
                    ledState = !ledState;
                    std::cout << "LED " << (ledState ? "ON" : "OFF") << std::endl;
                    break;

                case LED_CMD_SET_FREQ:
                    if (ledState) {
                        int newFreq = (int)blinkFrequency + (int)cmd.value;
                        if (newFreq >= 2 && newFreq <= 200) {
                            blinkFrequency = newFreq;
                            std::cout << "Frequency: " << blinkFrequency << " Hz" << std::endl;
                        }
                    }
                    break;
            }
        }

        // Blink logic
        if (ledState) {
            uint32_t halfPeriodMs = 500 / blinkFrequency;
            if (halfPeriodMs < 2) halfPeriodMs = 2;

            TickType_t xHalfPeriod = pdMS_TO_TICKS(halfPeriodMs);
            ledOn = !ledOn;
            gpio_put(LED_PIN, ledOn);
            vTaskDelayUntil(&xLastWakeTime, xHalfPeriod);
        } else {
            gpio_put(LED_PIN, 0);
            ledOn = false;
            vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(50));
        }
    }
}

int main() {
    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);
    gpio_put(LED_PIN, 0);

    gpio_init(ROT_A_PIN);
    gpio_set_dir(ROT_A_PIN, GPIO_IN);

    gpio_init(ROT_B_PIN);
    gpio_set_dir(ROT_B_PIN, GPIO_IN);

    gpio_init(ROT_SW_PIN);
    gpio_set_dir(ROT_SW_PIN, GPIO_IN);
    gpio_pull_up(ROT_SW_PIN);

    stdio_init_all();
    sleep_ms(2000);
    std::cout << "Rotary Encoder Control with FreeRTOS" << std::endl;
    std::cout << "Initial frequency: 2 Hz" << std::endl;

    // create event
    xEventQueue = xQueueCreate(10, sizeof(event_t));
    xLedCmdQueue = xQueueCreate(10, sizeof(led_cmd_t));

    if (xEventQueue == NULL || xLedCmdQueue == NULL) {
        std::cout << "Failed to create queues!" << std::endl;
        while (true) {
            gpio_put(LED_PIN, 1);
            sleep_ms(100);
            gpio_put(LED_PIN, 0);
            sleep_ms(900);
        }
    }

    // Register queues for debugging
    vQueueAddToRegistry(xEventQueue, "EventQueue");
    vQueueAddToRegistry(xLedCmdQueue, "LedCmdQueue");

    // Set up GPIO interrupts
    gpio_set_irq_enabled_with_callback(
        ROT_A_PIN, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &gpio_callback);
    gpio_set_irq_enabled(ROT_SW_PIN, GPIO_IRQ_EDGE_FALL, true);

    //Create tasks
    xTaskCreate(eventProcessorTask, "EventProcessor", 256, NULL, 2, NULL);
    xTaskCreate(ledBlinkerTask, "LEDBlinker", 256, NULL, 1, NULL);

    // Start scheduler
    vTaskStartScheduler();

    while (true) {
        gpio_put(LED_PIN, 1);
        sleep_ms(100);
        gpio_put(LED_PIN, 0);
        sleep_ms(100);
    }

    return 0;
}
